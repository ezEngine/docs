{
  "conceptual": "\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"3\">Shader resources are things like textures, samplers constant buffers etc. that need to be separately bound in the renderer for the shader to function. Each resource must be bound to a bind group and slot. Depending on the <a href=\"~/pages/docs/graphics/shaders/shaders-overview.md#platforms\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"3\">platform</a> used, the requirements for this binding can be very different. E.g. in Vulkan slot assignments must be unique within a bind group (Vulkan descriptor set) across all stages while in DX11 most slots only need to be unique within a stage. Not following these rules will result in a runtime error. Manually assigning slots is an option but is very tedious. To make this easier, the shader system can automate this process provided some constraints are met how resourced are declared.</p>\n<ol sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"5\">\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"5\">Currently, EZ does not support arrays of resources like <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"5\">Texture2D Diffuse[3]</code> in its shaders.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"6\">Resources must have unique names across all shader stages. The same resource name can be used in multiple stages as long as the resource it maps to is exactly the same.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"7\">Only four bind groups are supported (DX12 register space, Vulkan descriptor set).</li>\n</ol>\n<h2 id=\"resource-binding\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"9\">Resource Binding</h2>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"11\">The shader system only supports the DX11 / DX12 <a href=\"https://learn.microsoft.com/windows/win32/direct3d12/resource-binding-in-hlsl\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"11\">register syntax</a> for binding resources to bind groups. Both the bind group and slot can be bound. If no bind group is given, it is implicitly set to 0.</p>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"13\">EZ uses the following bind groups - resources should ideally be bound to these sets according to their update frequency:</p>\n<ul sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"14\">\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"14\"><strong sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"14\">BG_FRAME (0)</strong>: Should only contain resources that are set only once per frame or once per view.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"15\"><strong sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"15\">BG_RENDER_PASS (1)</strong>: Resources that are unqiue to a render pass. Also use it for small shaders that e.g. do some image processing within a render pass.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"16\"><strong sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"16\">BG_MATERIAL (2)</strong>: This group is normally occupied by the material resources. If a material exposes a resource like a texture, it must be put into this bind group.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"17\"><strong sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"17\">BG_DRAW_CALL (3)</strong>: Resources that change every few draw calls should go in here.</li>\n</ul>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"19\">Here is a list of a few examples of how to bind resources properly:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"21\">Texture2D Diffuse : register(t3, space1); // DX12 syntax, slot 3, bind group 1\nSamplerState MySampler : register(s4); // DX11 syntax slot 4, bind group 0 (default)\nByteAddressBuffer MyBuffer BIND_RESOURCE(SLOT_AUTO, BG_RENDER_PASS); // Slot Auto, bind group 1\nByteAddressBuffer MyBuffer2 BIND_GROUP(BG_RENDER_PASS); // Slot Auto, bind group 1\n\nCONSTANT_BUFFER(ezTestPositions, 1) // Slot 1, bind group 0 (default)\n{\n  ...\n};\n\nCONSTANT_BUFFER2(ezTestPositions, SLOT_AUTO, BG_MATERIAL) // Slot Auto, bind group 2\n{\n  ...\n};\n</code></pre>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"38\">The HLSL <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"38\">register</code> syntax is a bit impractical, so the macros <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"38\">BIND_RESOURCE(Slot, BindGroup)</code> and <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"38\">BIND_GROUP(BindGroup)</code> were introduced. These will generate invalid HLSL code which the shader compiler will eventually parse, organize and patch to do the correct thing on each platform. In most cases, you should only be concerned about deciding in which bind group a resource should reside in. Either use the macro <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"38\">SLOT_AUTO</code> when setting a slot or just use the <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"38\">BIND_GROUP</code> macro which omits the slot entirely.</p>\n<h3 id=\"c-resource-binding\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"40\">C++ resource binding</h3>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"42\">Before a shader can be used to render something, all the resources need to be bound to their respective bind groups. This is happening automatically for material resources but for custom shaders used in e.g. a custom render pass, this has to be done manually. To access the individual bind groups, use the following code:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"43\">// By default, GetBindGroup uses `EZ_GAL_BIND_GROUP_FRAME`.\nezBindGroupBuilder&amp; bindGroup = ezRenderContext::GetDefaultInstance()-&gt;GetBindGroup();\nezBindGroupBuilder&amp; bindGroupRenderPass = ezRenderContext::GetDefaultInstance()-&gt;GetBindGroup(EZ_GAL_BIND_GROUP_RENDER_PASS);\nezBindGroupBuilder&amp; bindGroupMaterial = ezRenderContext::GetDefaultInstance()-&gt;GetBindGroup(EZ_GAL_BIND_GROUP_MATERIAL);\nezBindGroupBuilder&amp; bindGroupDraw = ezRenderContext::GetDefaultInstance()-&gt;GetBindGroup(EZ_GAL_BIND_GROUP_DRAW_CALL);\n</code></pre>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"51\">When binding a resource, it is sufficient to only provide the resource name and GAL handle to bind the entire resource. If you want to bind only a subset of the resource, you can use <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"51\">ezGALTextureRange</code> or <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"51\">ezGALBufferRange</code> like this:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"53\">ezGALTextureRange textureRange;\ntextureRange.m_uiBaseMipLevel = uiMipMapIndex;\ntextureRange.m_uiBaseArraySlice = m_uiSpecularOutputIndex * 6;\ntextureRange.m_uiArraySlices = 6;\nbindGroup.BindTexture(&quot;ReflectionOutput&quot;, pFilteredSpecularOutput-&gt;m_TextureHandle, textureRange);\n// Or as a shorter form:\nbindGroup.BindTexture(&quot;ReflectionOutput&quot;, pFilteredSpecularOutput-&gt;m_TextureHandle, {m_uiSpecularOutputIndex * 6, 6, uiMipMapIndex, EZ_GAL_ALL_MIP_LEVELS});\n</code></pre>\n<h2 id=\"constant-buffers\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"63\">Constant Buffers</h2>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"65\">Constant buffers map to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"65\">ezGALShaderResourceType::ConstantBuffer</code> in C++.\nTo facilitate C++ interop, constant buffers should be placed into a separate header file that looks like this:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"68\">#pragma once\n#include &lt;Shaders/Common/ConstantBufferMacros.h&gt;\n\nCONSTANT_BUFFER(ezTestPositions, 3)\n{\n  FLOAT4(Vertex0);\n  FLOAT4(Vertex1);\n  FLOAT4(Vertex2);\n};\n</code></pre>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"79\">By using the macros defined in <strong sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"79\">ConstantBufferMacros.h</strong> like <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"79\">CONSTANT_BUFFER</code> and the data types like <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"79\">FLOAT4</code>, the file can be included in both shader and C++ code. This makes it easy to create an instance of the constant buffer as a C++ struct in code to update it. Care must be taken to ensure that the constant buffer has the same layout in C++ and HLSL though:</p>\n<ol sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"80\">\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"80\">Make sure that the size of your struct is a multiple of 16 bytes. Fill out any missing bytes with dummy <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"80\">FLOAT1</code> entries.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"81\">A <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"81\">FLOAT3</code> can't be followed by another <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"81\">FLOAT3</code>. It should be followed by a <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"81\">FLOAT1</code> first or some other types of the same byte counts to ensure the next <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"81\">FLOAT3</code> starts at a 16 byte boundary. This is necessary as the layout rules are different between HLSL and C++.</li>\n</ol>\n<h2 id=\"push-constants\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"83\">Push Constants</h2>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"85\">Push constants map to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"85\">ezGALShaderResourceType::PushConstants</code> in C++. Push constants allow for fast updates of a small set of bytes. Usually at least 128 bytes. You can check <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"85\">ezGALDeviceCapabilities::m_uiMaxPushConstantsSize</code> for the max push constant buffer size. On platforms that don't support push constants like DX11, this is emulated via a constant buffer. Only one push constants block is supported across all shader stages of a shader. Like with constant buffers, special macros have to be used and the declaration should be put into a separate header so it can be included in both shader and C++ code:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"87\">// Header:\n#pragma once\n#include &lt;Shaders/Common/ConstantBufferMacros.h&gt;\n\nBEGIN_PUSH_CONSTANTS(ezTestData)\n{\n  FLOAT4(VertexColor);\n  FLOAT4(Vertex0);\n  FLOAT4(Vertex1);\n  FLOAT4(Vertex2);\n}\nEND_PUSH_CONSTANTS(ezTestData)\n\n// Shader:\nfloat4 main(VS_OUT a) : SV_Target\n{\n  return GET_PUSH_CONSTANT(ezTestData, VertexColor);\n}\n\n// C++:\nezTestData constants;\nconstants.VertexColor = ...;\npContext-&gt;SetPushConstants(&quot;ezTestData&quot;, constants);\n</code></pre>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"113\">The <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"113\">BEGIN_PUSH_CONSTANTS</code> and <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"113\">END_PUSH_CONSTANTS</code> macros define the struct. Unlike with constant buffers, you can't simply access the values inside a shader by just the name of the variable, e.g. <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"113\">VertexColor</code>. This is because depending on the platform, a different syntax needs to be used to access the content. To make the same shader compile on all platforms, you need to use the <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"113\">GET_PUSH_CONSTANT(Name, Constant)</code> macro to access a member of the push constant buffer.</p>\n<h2 id=\"samplers\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"115\">Samplers</h2>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">Samplers map to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">ezGALShaderResourceType::Sampler</code> or <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">ezGALShaderResourceType::TextureAndSampler</code> in C++. Two types of samplers are supported: <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">SamplerState</code> and <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">SamplerComparisonState</code>. The naming of the samplers is important, as it can be used to optimize your workflow. ezEngine has a concept of immutable Samplers, these samplers are automatically bound so you can use them in the shader without needing to define them in C++. Immutable samplers are registered in code via <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">ezGALImmutableSamplers::RegisterImmutableSampler</code>. Currently, these samplers are registered: <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">LinearSampler</code>, <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">LinearClampSampler</code>, <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">PointSampler</code> and <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"117\">PointClampSampler</code>.</p>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"119\">ezEngine does not allow for two different resources to have the same name, the only exception is textures and samplers which can have the same name by calling the sampler <em sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"119\">NAME_AutoSampler</em>. The compiler will rename the sampler to <em sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"119\">NAME</em> and on platforms that support combined image samplers both will be combined into a single resource of type <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"119\">ezGALShaderResourceType::TextureAndSampler</code>. The benefit of this approach is that when binding a texture resource to a material for example, the texture resource can define both the texture as well as the sampler state, binding both to the same name.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"121\">SamplerState DiffuseSampler;\nSamplerComparisonState ShadowSampler;\n// Auto sampler combines with texture of the same name: \nTexture2D BaseTexture;\nSamplerState BaseTexture_AutoSampler;\n</code></pre>\n<h2 id=\"textures\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"129\">Textures</h2>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"131\">Textures map to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"131\">ezGALShaderResourceType::Texture</code> or <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"131\">ezGALShaderResourceType::TextureAndSampler</code> in C++ (see samplers above). ezEngine supports all HLSL texture types except for 1D textures. You can work around this by creating 1xN 2DTextures.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"133\">Texture1D texture1D; // 1D textures currently not supported.\nTexture1DArray texture1DArray; // 1D textures currently not supported.\nTexture2D texture2D;\nTexture2DArray texture2DArray;\nTexture2DMS&lt;float4&gt; texture2DMS;\nTexture2DMSArray&lt;float4&gt; texture2DMSArray;\nTexture3D texture3D;\nTextureCube textureCube;\nTextureCubeArray textureCubeArray;\n</code></pre>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"145\">Read-write variants are also supported and map to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"145\">ezGALShaderResourceType::TextureRW</code> in C++.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"147\">RWTexture1D&lt;float&gt; rwTexture1D; // 1D textures currently not supported.\nRWTexture1DArray&lt;float2&gt; rwTexture1DArray; // 1D textures currently not supported.\nRWTexture2D&lt;float3&gt; rwTexture2D;\nRWTexture2DArray&lt;float4&gt; rwTexture2DArray;\nRWTexture3D&lt;uint&gt; rwTexture3D;\n</code></pre>\n<h2 id=\"buffers\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"155\">Buffers</h2>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"157\">There are three types of buffers supported by EZ:</p>\n<ol sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"158\">\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"158\">HLSL's <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"158\">Buffer&lt;T&gt;</code> type is very similar to a 1D texture. A buffer of the same type T needs to be bound to the resource. Maps to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"158\">ezGALShaderResourceType::TexelBuffer</code> in C++.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"159\"><code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"159\">StructuredBuffer&lt;T&gt;</code> should follow the same rules as for constant buffers: Put the declaration in a separate header file to allow access to it from C++ and ensure each struct is 16 bytes aligned. Maps to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"159\">ezGALShaderResourceType::StructuredBuffer</code> in C++.</li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"160\"><code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"160\">ByteAddressBuffer</code> in just an array of bytes. A raw buffer needs to be bound to the resource. With HLSL 5.1, you can cast any offset of the buffer into a struct. Maps to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"160\">ezGALShaderResourceType::ByteAddressBuffer</code> in C++.</li>\n</ol>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"162\">// Header:\n#pragma once\n#include &lt;Shaders/Common/ConstantBufferMacros.h&gt;\n\nstruct EZ_SHADER_STRUCT PerInstanceData\n{\n  TRANSFORM(ObjectToWorld);\n};\n\n// Shader:\nBuffer&lt;uint&gt; buffer;\nStructuredBuffer&lt;PerInstanceData&gt; structuredBuffer;\nByteAddressBuffer byteAddressBuffer;\n</code></pre>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"178\">Read-write variants of these buffers are also supported and map to <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"178\">ezGALShaderResourceType::TexelBufferRW</code>, <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"178\">ezGALShaderResourceType::StructuredBufferRW</code> and <code sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"178\">ezGALShaderResourceType::ByteAddressBufferRW</code> respectively.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"180\">RWBuffer&lt;uint&gt; rwBuffer;\nRWStructuredBuffer&lt;ezPerInstanceData&gt; rwStructuredBuffer;\nRWByteAddressBuffer rwByteAddressBuffer;\n</code></pre>\n<h2 id=\"append--consume-buffers\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"186\">Append / Consume Buffers</h2>\n<p sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"188\">TODO: Future work: Append / consume buffers can be defined in shaders and are correctly reflected, but EZ does not support binding resources to them right now.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"190\">// Header:\n#pragma once\n#include &lt;Shaders/Common/ConstantBufferMacros.h&gt;\n\nstruct EZ_SHADER_STRUCT ezAppendData\n{\n  FLOAT2(Value);\n};\n\n// Shader:\nAppendStructuredBuffer&lt;ezAppendData&gt; appendStructuredBuffer;\nConsumeStructuredBuffer&lt;ezAppendData&gt; consumeStructuredBuffer;\n</code></pre>\n<h2 id=\"see-also\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"205\">See Also</h2>\n<ul sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"207\">\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"207\"><a href=\"~/pages/docs/graphics/shaders/shaders-overview.md\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"207\">Shaders</a></li>\n<li sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"208\"><a href=\"~/pages/docs/tools/shadercompiler.md\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"208\">ShaderCompiler</a></li>\n</ul>\n",
  "type": "Conceptual",
  "source": {
    "remote": {
      "path": "pages/docs/graphics/shaders/shader-resources.md",
      "branch": "main",
      "repo": "https://github.com/ezEngine/docs-src"
    },
    "startLine": 0,
    "endLine": 0
  },
  "path": "pages/docs/graphics/shaders/shader-resources.md",
  "documentation": {
    "remote": {
      "path": "pages/docs/graphics/shaders/shader-resources.md",
      "branch": "main",
      "repo": "https://github.com/ezEngine/docs-src"
    },
    "startLine": 0,
    "endLine": 0
  },
  "_appFaviconPath": "assets/images/favicon.svg",
  "_appFooter": "Hello",
  "_appLogoPath": "assets/images/EZ-text.svg",
  "_appName": "ezEngine",
  "_appTitle": "ezEngine",
  "_enableGoogleAnalytics": true,
  "_enableNewTab": true,
  "_enableSearch": true,
  "_gitContribute": {
    "repo": "https://github.com/ezEngine/docs-src",
    "branch": "main"
  },
  "_systemKeys": [
    "conceptual",
    "type",
    "source",
    "path",
    "documentation",
    "title",
    "rawTitle",
    "wordCount"
  ],
  "rawTitle": "<h1 id=\"shaders-resources\" sourcefile=\"pages/docs/graphics/shaders/shader-resources.md\" sourcestartlinenumber=\"1\">Shaders Resources</h1>",
  "title": "Shaders Resources",
  "wordCount": 1505,
  "_key": "pages/docs/graphics/shaders/shader-resources.md",
  "_navKey": "~/toc.yml",
  "_navPath": "toc.html",
  "_navRel": "../../../../toc.html",
  "_path": "pages/docs/graphics/shaders/shader-resources.html",
  "_rel": "../../../../",
  "_tocKey": "~/pages/docs/toc.md",
  "_tocPath": "pages/docs/toc.html",
  "_tocRel": "../../toc.html",
  "__global": {
    "namespacesInSubtitle": "Namespaces",
    "classesInSubtitle": "Classes",
    "structsInSubtitle": "Structs",
    "interfacesInSubtitle": "Interfaces",
    "enumsInSubtitle": "Enums",
    "delegatesInSubtitle": "Delegates",
    "constructorsInSubtitle": "Constructors",
    "fieldsInSubtitle": "Fields",
    "propertiesInSubtitle": "Properties",
    "methodsInSubtitle": "Methods",
    "eventsInSubtitle": "Events",
    "operatorsInSubtitle": "Operators",
    "eiisInSubtitle": "Explicit Interface Implementations",
    "functionsInSubtitle": "Functions",
    "variablesInSubtitle": "Variables",
    "typeAliasesInSubtitle": "Type Aliases",
    "membersInSubtitle": "Members",
    "improveThisDoc": "Edit this page",
    "viewSource": "View Source",
    "inheritance": "Inheritance",
    "derived": "Derived",
    "inheritedMembers": "Inherited Members",
    "package": "Package",
    "namespace": "Namespace",
    "assembly": "Assembly",
    "syntax": "Syntax",
    "overrides": "Overrides",
    "implements": "Implements",
    "remarks": "Remarks",
    "examples": "Examples",
    "seealso": "See Also",
    "declaration": "Declaration",
    "parameters": "Parameters",
    "typeParameters": "Type Parameters",
    "type": "Type",
    "name": "Name",
    "description": "Description",
    "returns": "Returns",
    "fieldValue": "Field Value",
    "propertyValue": "Property Value",
    "eventType": "Event Type",
    "variableValue": "Variable Value",
    "typeAliasType": "Type Alias Type",
    "exceptions": "Exceptions",
    "condition": "Condition",
    "extensionMethods": "Extension Methods",
    "note": "Note",
    "warning": "Warning",
    "tip": "Tip",
    "important": "Important",
    "caution": "Caution",
    "tocToggleButton": "Show / Hide Table of Contents",
    "tocFilter": "Filter by title",
    "search": "Search",
    "searchResults": "Search Results for",
    "searchResultsCount": "{count} results for \"{query}\"",
    "searchNoResults": "No results for \"{query}\"",
    "pageFirst": "First",
    "pagePrev": "Previous",
    "pageNext": "Next",
    "pageLast": "Last",
    "inThisArticle": "In this article",
    "nextArticle": "Next",
    "prevArticle": "Previous",
    "backToTop": "Back to top",
    "themeLight": "Light",
    "themeDark": "Dark",
    "themeAuto": "Auto",
    "changeTheme": "Change theme",
    "copy": "Copy",
    "downloadPdf": "Download PDF",
    "_shared": {}
  },
  "_disableToc": false,
  "docurl": "https://github.com/ezEngine/docs-src/blob/main/pages/docs/graphics/shaders/shader-resources.md/#L1"
}