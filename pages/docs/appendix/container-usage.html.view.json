{
  "conceptual": "\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"3\">ezEngine has the following container classes:</p>\n<ul sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"5\">\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"5\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"5\">ezStaticArray</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"6\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"6\">ezHybridArray</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"7\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"7\">ezDynamicArray</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"8\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"8\">ezStaticRingBuffer</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"9\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"9\">ezDeque</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"10\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"10\">ezList</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"11\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"11\">ezMap</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"12\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"12\">ezSet</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"13\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"13\">ezHashTable</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"14\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"14\">ezArrayMap</code></li>\n</ul>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"16\">The following containers store their data as contiguous arrays:</p>\n<ul sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"18\">\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"18\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"18\">ezStaticArray</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"19\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"19\">ezHybridArray</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"20\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"20\">ezDynamicArray</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"21\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"21\">ezStaticRingBuffer</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"22\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"22\">ezArrayMap</code></li>\n</ul>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"24\">The following containers are built on top of <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"24\">ezDeque</code> and thus share some performance characteristics:</p>\n<ul sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"26\">\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"26\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"26\">ezList</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"27\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"27\">ezMap</code></li>\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"28\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"28\">ezSet</code></li>\n</ul>\n<h2 id=\"when-to-use-which-container-type\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"30\">When to use which Container Type</h2>\n<h3 id=\"arrays\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"32\">Arrays</h3>\n<h4 id=\"general-guidelines\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"34\">General Guidelines</h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"36\">For arrays, <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"36\">ezHybridArray</code>, <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"36\">ezDynamicArray</code> and <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"36\">ezDeque</code> are the most important containers.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"38\">If you know or have a guess how much data you will need, always use this information in a call to <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"38\">Reserve</code> to ensure that the containers can allocate data once (or at least much less), and do not need to reallocate several times.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"40\">Never remove an element in between (using <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"40\">RemoveAt</code>), unless there is really no other way (and hopefully your array is small). Prefer <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"40\">RemoveAtAndSwap</code> to replace the removed element by the last element in the array instead (this will destroy the order though).\nSimilarly, never insert elements anywhere else than at the end.\nThe only exception is <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"42\">ezDeque</code>, which is very efficient at insertion and removal of elements at both ends.</p>\n<h4 id=\"ezhybridarray\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"46\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"46\">ezHybridArray</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"48\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"48\">ezHybridArray</code> uses an internal fixed size cache (which you can specify as a template argument). When you create an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"48\">ezHybridArray</code> on the stack, that data is also allocated on the stack. This is the most important container for writing performance critical yet safe code. <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"48\">ezHybridArray</code> allows to implement many algorithms without the need to use dynamic allocations.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"50\">Prefer <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"50\">ezHybridArray</code> when you have a use case where you typically have a small set of elements, but it might be larger in some situations. <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"50\">ezHybridArray</code> will give you the performance of an immediately available array on the stack, combined with the safety of a dynamically allocated array on the heap, as it will reallocate data dynamically, whenever its internal storage is insufficient.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"52\">However, be careful not to make the internal buffer too large. When creating <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"52\">ezHybridArrays</code> on the stack, you should not use more than a few KB for the internal cache, as you increase the risk for stack overflows. You should usually try to stay below <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"52\">(2KB / sizeof(Type))</code> for the number of elements in the <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"52\">ezHybridArray</code> cache.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"54\"><strong sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"54\">Note:</strong> <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"54\">ezHybridArray</code> is derived from <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"54\">ezDynamicArray</code>, that means every function that takes an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"54\">ezDynamicArray</code> (even for writing output to), can be given an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"54\">ezHybridArray</code>.</p>\n<h4 id=\"ezdynamicarray\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"57\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"57\">ezDynamicArray</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"59\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"59\">ezDynamicArray</code> always allocates its data on the heap. The upside is, that it has a very low memory overhead, as long as it is empty, and it can handle any number of elements.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"61\">Prefer <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"61\">ezDynamicArray</code> if your working set is generally larger and when you know how many elements it needs to hold before you fill it up. Use <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"61\">Reserve</code> or <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"61\">SetCount</code> BEFORE you start adding data to it, to prevent unnecessary reallocation later, as those are very costly.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"63\">Also prefer <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"63\">ezDynamicArray</code> if the memory overhead in the empty state is of concern.</p>\n<h4 id=\"ezdeque\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"66\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"66\">ezDeque</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"68\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"68\">ezDeque</code> stores its data as several chunks of contiguous arrays. An additional &quot;redirection array&quot; is used to know how to index into these chunks.\n<code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"69\">ezDeque</code> requires one pointer indirection to make a lookup into its data.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"71\">The deque is the only array container that does not store its data in one contiguous block of memory. Be aware of that, you cannot <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"71\">memcpy</code> or <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"71\">memcmp</code> data in a deque with more than one element, as the next element might be stored somewhere completely different.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"73\">However a deque NEVER relocates an existing element in memory, either. That means once an element is inserted into a deque, you can safely store pointers to it, as it will not move around in memory (unless it is deleted, of course).</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"75\">Deques allocate their data in chunks. So whenever the memory is insufficient, a new chunk that can hold a fixed number of elements is allocated. One chunk is typically 4 KB in size. That means if you store <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"75\">floats</code> in a deque, one chunk can hold 1000 values. Thus this is the 'minimum' memory usage of a deque, unless it is completely empty still.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"77\">As such <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"77\">ezDeques</code> are very efficient for iteration (most of the data is contiguous) and they are very dynamic, as their size can grow dynamically without the need to reallocate and copy previous data, as the other array types would need to do.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"79\">Therefore prefer <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"79\">ezDeques</code> whenever you need to have nearly the performance of an array, but have very dynamic data sets, that are difficult to predict in size, or that vary all the time.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"81\">As deques are optimized for insertion and removal at both ends, <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"81\">ezDeques</code> are perfectly suited as fifo queues and dynamic ring-buffers.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"83\">The memory overhead of <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"83\">ezDeques</code> is rather high, so do not use it for small data-sets (here <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"83\">ezHybridArray</code> is typically the best container).</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"85\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"85\">ezDeques</code> are also very well suited, whenever you have large objects to store that are very costly to construct or copy around, and you want to prevent those operations by all means, such that you do not want a container reallocation to trigger that.</p>\n<h4 id=\"ezstaticarray\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"90\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"90\">ezStaticArray</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"92\">This is a container that only stores a static array internally and cannot resize itself to be larger than that. Use this in code that has a definite upper limit of elements and whenever you must prevent the usage of any allocator by all means (such as for global variables).</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"94\">Typically there should be no need for this container, as <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"94\">ezHybridArray</code> delivers the same performance advantages and the safety of reallocating to the required size dynamically.</p>\n<h4 id=\"ezstaticringbuffer\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"98\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"98\">ezStaticRingBuffer</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"100\">Use this when you need a ring-buffer that shall have a fixed size. Use <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"100\">ezDeque</code> if you need a dynamically resizing ring-buffer.</p>\n<h3 id=\"lists\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"104\">Lists</h3>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"106\">There is only one implementation of a doubly linked list: <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"106\">ezList</code></p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"108\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"108\">ezList</code> is internally built on top of a <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"108\">ezDeque</code>. As such the memory requirements are the same.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"110\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"110\">ezList</code> is optimized for inserting and removing objects frequently. Iterating over its elements might be slow due to excessive cache misses.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"112\">You should typically not use <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"112\">ezList</code> in code that is performance critical. Use it when you have data-sets of unpredictable size that need to be sorted or rearranged very dynamically. For example when you read a complex data set which then needs to be processed and sorted by different criteria, which might delete and insert elements at random positions, then prefer an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"112\">ezList</code>. However, once that step is finished, you should copy your sorted data into some array container for faster access.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"114\">Nodes in an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"114\">ezList</code> are never relocated in memory, as such iterators stay valid as long as the element is still alive.</p>\n<h3 id=\"associative-containers\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"118\">Associative Containers</h3>\n<h4 id=\"ezmap-and-ezset\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"120\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"120\">ezMap</code> and <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"120\">ezSet</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"122\">Both containers are basically the same, except that <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"122\">ezMap</code> stores a 'value' for each 'key', whereas a set only stores 'keys'.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"124\">Use <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"124\">ezMap</code> whenever you need to be able to look up an entry with a key. Use <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"124\">ezSet</code> whenever you simply need to know whether some element is present or to merge data-sets down to all the unique elements.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"126\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"126\">ezMap</code> and <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"126\">ezSet</code> are built on top of <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"126\">ezDeque</code>, similar to <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"126\">ezList</code>, that means they are quite heavy-weight in their memory consumption, however they can grow in size efficiently. As with <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"126\">ezList</code>, iterators (and pointers) to elements stay valid, as long as the element is alive, i.e. the data is never relocated.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"128\">Insertion, lookup and removal are all <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"128\">O(log n)</code> operations, since they are red-black trees internally and thus always perfectly balanced.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"130\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"130\">ezMap</code> and <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"130\">ezSet</code> are well suited for very dynamic data sets (where a lot of insertions and removals are done, while also using it for lookup). If you have a use-case where you insert once and then lookup often, a sorted array, such as <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"130\">ezArrayMap</code>, or an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"130\">ezHashTable</code> might be more efficient.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"132\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"132\">ezMap</code> and <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"132\">ezSet</code> only require a simple comparer to be able to sort elements in a strictly weak ordering. As such they are well suited to handle objects that can be difficult to be hashed.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"134\">Note that the nodes in the Map/Set each contain one element of their key/value type and those are stored in an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"134\">ezDeque</code>. As such, when you put an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"134\">ezHybridArray</code> (or an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"134\">ezString</code>) into an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"134\">ezMap</code>, only one allocation is needed to allocate all the memory for a chunk (in the <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"134\">ezDeque</code>) of data, which holds a large number of nodes, which already embed the data of their keys/values (e.g. <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"134\">ezHybridArray</code>). Thus you can get away with very few memory allocations.\nIf however you store an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"135\">ezDynamicArray</code> in an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"135\">ezMap</code>, each element still needs to allocate its own internal storage, which means you will get one additional allocation per element.</p>\n<h4 id=\"ezarraymap\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"137\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"137\">ezArrayMap</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"139\">This container provides similar functionality as <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"139\">ezMap</code> but should be more efficient in scenarios where elements are looked up more often than they are inserted or removed. The implementation simply uses an array that is kept sorted, such that lookups can be done in a more cache friendly manner.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"141\">If all you need is an associative container and your use case consists of changing the container infrequently, but looking up elements frequently (which is very often the case), you should prefer this container.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"143\">Note, however, that this container will rearrange elements in memory whenever it needs to be sorted. In contrast an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"143\">ezMap</code> guarantees that elements never move in memory, allowing to store pointers to the memory locations. Likewise the iterators of an <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"143\">ezMap</code> stay valid as long as an elements resides in the map. For <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"143\">ezArrayMap</code> this is not true, the index at which an element is stored can change whenever any element is added or removed.</p>\n<h4 id=\"ezhashtable\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"145\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"145\">ezHashTable</code></h4>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"147\">The <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"147\">ezHashTable</code> is optimized for very fast lookup, which should typically be a <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"147\">O(1)</code> operation. Prefer the hash table whenever you will have a data set that is modified infrequently, but lookups will be done often and need to be as fast as possible.</p>\n<p sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"149\"><code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"149\">ezHashTable</code> may relocate its internal memory, which means iterators to its elements may not stay valid when the table is modified.\nMake sure to <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"150\">Reserve</code> how much elements you probably will put into the <code sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"150\">ezHashTable</code>, to ensure fewer reallocations, but also to avoid hash-collisions and thus to improve overall performance.</p>\n<h2 id=\"see-also\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"152\">See Also</h2>\n<ul sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"154\">\n<li sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"154\"><a href=\"~/pages/docs/appendix/string-usage.md\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"154\">String Usage Guidelines</a></li>\n</ul>\n",
  "type": "Conceptual",
  "source": {
    "remote": {
      "path": "pages/docs/appendix/container-usage.md",
      "branch": "main",
      "repo": "https://github.com/ezEngine/docs-src"
    },
    "startLine": 0,
    "endLine": 0
  },
  "path": "pages/docs/appendix/container-usage.md",
  "documentation": {
    "remote": {
      "path": "pages/docs/appendix/container-usage.md",
      "branch": "main",
      "repo": "https://github.com/ezEngine/docs-src"
    },
    "startLine": 0,
    "endLine": 0
  },
  "_appFaviconPath": "assets/images/favicon.svg",
  "_appFooter": "Hello",
  "_appLogoPath": "assets/images/EZ-text.svg",
  "_appName": "ezEngine",
  "_appTitle": "ezEngine",
  "_enableGoogleAnalytics": true,
  "_enableNewTab": true,
  "_enableSearch": true,
  "_gitContribute": {
    "repo": "https://github.com/ezEngine/docs-src",
    "branch": "main"
  },
  "_systemKeys": [
    "conceptual",
    "type",
    "source",
    "path",
    "documentation",
    "title",
    "rawTitle",
    "wordCount"
  ],
  "rawTitle": "<h1 id=\"container-usage-guidelines\" sourcefile=\"pages/docs/appendix/container-usage.md\" sourcestartlinenumber=\"1\">Container Usage Guidelines</h1>",
  "title": "Container Usage Guidelines",
  "wordCount": 1678,
  "_key": "pages/docs/appendix/container-usage.md",
  "_navKey": "~/toc.yml",
  "_navPath": "toc.html",
  "_navRel": "../../../toc.html",
  "_path": "pages/docs/appendix/container-usage.html",
  "_rel": "../../../",
  "_tocKey": "~/pages/docs/toc.md",
  "_tocPath": "pages/docs/toc.html",
  "_tocRel": "../toc.html",
  "__global": {
    "namespacesInSubtitle": "Namespaces",
    "classesInSubtitle": "Classes",
    "structsInSubtitle": "Structs",
    "interfacesInSubtitle": "Interfaces",
    "enumsInSubtitle": "Enums",
    "delegatesInSubtitle": "Delegates",
    "constructorsInSubtitle": "Constructors",
    "fieldsInSubtitle": "Fields",
    "propertiesInSubtitle": "Properties",
    "methodsInSubtitle": "Methods",
    "eventsInSubtitle": "Events",
    "operatorsInSubtitle": "Operators",
    "eiisInSubtitle": "Explicit Interface Implementations",
    "functionsInSubtitle": "Functions",
    "variablesInSubtitle": "Variables",
    "typeAliasesInSubtitle": "Type Aliases",
    "membersInSubtitle": "Members",
    "improveThisDoc": "Edit this page",
    "viewSource": "View Source",
    "inheritance": "Inheritance",
    "derived": "Derived",
    "inheritedMembers": "Inherited Members",
    "package": "Package",
    "namespace": "Namespace",
    "assembly": "Assembly",
    "syntax": "Syntax",
    "overrides": "Overrides",
    "implements": "Implements",
    "remarks": "Remarks",
    "examples": "Examples",
    "seealso": "See Also",
    "declaration": "Declaration",
    "parameters": "Parameters",
    "typeParameters": "Type Parameters",
    "type": "Type",
    "name": "Name",
    "description": "Description",
    "returns": "Returns",
    "fieldValue": "Field Value",
    "propertyValue": "Property Value",
    "eventType": "Event Type",
    "variableValue": "Variable Value",
    "typeAliasType": "Type Alias Type",
    "exceptions": "Exceptions",
    "condition": "Condition",
    "extensionMethods": "Extension Methods",
    "note": "Note",
    "warning": "Warning",
    "tip": "Tip",
    "important": "Important",
    "caution": "Caution",
    "tocToggleButton": "Show / Hide Table of Contents",
    "tocFilter": "Filter by title",
    "search": "Search",
    "searchResults": "Search Results for",
    "searchResultsCount": "{count} results for \"{query}\"",
    "searchNoResults": "No results for \"{query}\"",
    "pageFirst": "First",
    "pagePrev": "Previous",
    "pageNext": "Next",
    "pageLast": "Last",
    "inThisArticle": "In this article",
    "nextArticle": "Next",
    "prevArticle": "Previous",
    "backToTop": "Back to top",
    "themeLight": "Light",
    "themeDark": "Dark",
    "themeAuto": "Auto",
    "changeTheme": "Change theme",
    "copy": "Copy",
    "downloadPdf": "Download PDF",
    "_shared": {}
  },
  "_disableToc": false,
  "docurl": "https://github.com/ezEngine/docs-src/blob/main/pages/docs/appendix/container-usage.md/#L1"
}