{
  "conceptual": "\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"3\">The ezEngine reflection system allows to inspect structs and classes at runtime. It is used primarily for communication with tools and serialization.\nThe reflection system is macro-based, meaning that it is not generated automatically but needs to be written manually for each type, member, etc that needs to be known at runtime.</p>\n<h2 id=\"types\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"6\">Types</h2>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"8\">There are four distinct types that can be represented by reflection: classes, structs, enums and bitflags. Each is represented by the <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"8\">ezRTTI</code> class that stores the type information.</p>\n<h3 id=\"classes\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"10\">Classes</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"12\">Classes are separated into two types: dynamic and static reflected. Dynamic classes derive from <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"12\">ezReflectedClass</code> which allows you to determine its type using <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"12\">ezReflectedClass::GetDynamicRTTI()</code>. So with a pointer to an <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"12\">ezReflectedClass</code> you can access its type information.</p>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"14\">A static reflected class does not derive from <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"14\">ezReflectedClass</code> so it is not possible to get the RTTI information in a common way. However, if you know the type of a variable you can use the template function <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"14\">ezGetStaticRTTI</code> to retrieve the <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"14\">ezRTTI</code> instance of a specific type. Alternatively, you can also search for a type by name using <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"14\">ezRTTI::FindTypeByName()</code>.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"16\">ezReflectedClass* pTest = new ezDynamicTestClass;\nconst ezRTTI* pRtti = pTest-&gt;GetDynamicRTTI();\nconst ezRTTI* pRtti2 = ezGetStaticRTTI&lt;ezDynamicTestClass&gt;();\nconst ezRTTI* pRtti3 = ezRTTI::FindTypeByName(&quot;ezDynamicTestClass&quot;);\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"23\">Declaring a dynamic class involves deriving from <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"23\">ezReflectedClass</code>, adding the <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"23\">EZ_ADD_DYNAMIC_REFLECTION(SELF, BASE_TYPE)</code> macro into the class body and adding a <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"23\">EZ_BEGIN_DYNAMIC_REFLECTED_TYPE(Type, Version, AllocatorType)</code> block into a compilation unit.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"25\">//Header\nclass ezDynamicTestClass : public ezReflectedClass\n{\n  EZ_ADD_DYNAMIC_REFLECTION(ezDynamicTestClass, ezReflectedClass);\n};\n</code></pre>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"33\">//Cpp\nEZ_BEGIN_DYNAMIC_REFLECTED_TYPE(ezDynamicTestClass, 1, ezRTTIDefaultAllocator&lt;ezDynamicTestClass&gt;)\nEZ_END_DYNAMIC_REFLECTED_TYPE\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"39\">Declaring a static class is very similar to declaring a dynamic class. However, you need to declare the type outside the class via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"39\">EZ_DECLARE_REFLECTABLE_TYPE(Linkage, TYPE)</code> and use <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"39\">EZ_BEGIN_STATIC_REFLECTED_TYPE(Type, BaseType, Version, AllocatorType)</code> in a compilation unit. If a class has no base class, use the dummy class <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"39\">ezNoBase</code> instead.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"41\">// Header\nclass ezStaticTestClass\n{\n};\nEZ_DECLARE_REFLECTABLE_TYPE(EZ_NO_LINKAGE, ezStaticTestClass);\n</code></pre>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"49\">// Cpp\nEZ_BEGIN_STATIC_REFLECTED_TYPE(ezStaticTestClass, ezNoBase, 1, ezRTTIDefaultAllocator&lt;ezStaticTestClass&gt;);\nEZ_END_STATIC_REFLECTED_TYPE\n</code></pre>\n<h3 id=\"structs\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"55\">Structs</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"57\">Structs are identical to static reflected classes so you can use the exact same macros.</p>\n<h3 id=\"enums\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"59\">Enums</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"61\">Enums are limited to structured enums, i.e. those used by the <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"61\">ezEnum</code> class. Declaration is similar to static classes, but you use <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"61\">EZ_BEGIN_STATIC_REFLECTED_ENUM(Type, Version)</code> instead in the compilation unit code.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"63\">// Header\nstruct ezExampleEnum\n{\n    typedef ezInt8 StorageType;\n    enum Enum\n    {\n    Value1 = 1,          // normal value\n    Value2 = -2,         // normal value\n    Value3 = 4,          // normal value\n    Default = Value1     // Default initialization value (required)\n    };\n};\nEZ_DECLARE_REFLECTABLE_TYPE(EZ_NO_LINKAGE, ezExampleEnum);\n</code></pre>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"79\">// Cpp\nEZ_BEGIN_STATIC_REFLECTED_ENUM(ezExampleEnum, 1)\n  EZ_ENUM_CONSTANTS(ezExampleEnum::Value1, ezExampleEnum::Value2)\n  EZ_ENUM_CONSTANT(ezExampleEnum::Value3),\nEZ_END_STATIC_REFLECTED_ENUM\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"87\">The enum constants can either be declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"87\">EZ_ENUM_CONSTANTS()</code> or <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"87\">EZ_ENUM_CONSTANT(Value)</code> inside the begin / end block of the enum declaration. An enum type can be identified by its base type which is always the dummy <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"87\">ezEnumBase</code>.</p>\n<h3 id=\"bitflags\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"89\">Bitflags</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"91\">Bitflags are limited to structured bitflags, i.e. those used by the <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"91\">ezBitflags</code> class. Declaration is similar to static classes, but you use <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"91\">EZ_BEGIN_STATIC_REFLECTED_BITFLAGS(Type, Version)</code> instead in the compilation unit code.</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"93\">// Header\nstruct ezExampleBitflags\n{\n    typedef ezUInt64 StorageType;\n    enum Enum : ezUInt64\n    {\n    Value1 = EZ_BIT(0),  // normal value\n    Value2 = EZ_BIT(31), // normal value\n    Value3 = EZ_BIT(63), // normal value\n    Default = Value1     // Default initialization value (required)\n    };\n\n    struct Bits\n    {\n    StorageType Value1 : 1;\n    StorageType Padding : 30;\n    StorageType Value2 : 1;\n    StorageType Padding2 : 31;\n    StorageType Value3 : 1;\n    };\n};\nEZ_DECLARE_REFLECTABLE_TYPE(EZ_NO_LINKAGE, ezExampleBitflags);\n</code></pre>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"118\">// Cpp\nEZ_BEGIN_STATIC_REFLECTED_BITFLAGS(ezExampleBitflags, 1)\n  EZ_BITFLAGS_CONSTANTS(ezExampleBitflags::Value1, ezExampleBitflags::Value2)\n  EZ_BITFLAGS_CONSTANT(ezExampleBitflags::Value3),\nEZ_END_STATIC_REFLECTED_BITFLAGS();\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"126\">The bitflags constants can either be declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"126\">EZ_BITFLAGS_CONSTANTS()</code> or <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"126\">EZ_BITFLAGS_CONSTANT(Value)</code> inside the begin / end block of the bitflags declaration. A bitflags type can be identified by its base type which is always the dummy <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"126\">ezBitflagsBase</code>.</p>\n<h2 id=\"properties\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"128\">Properties</h2>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"130\">Properties are the most important information in a type as they define the data inside it. The properties of a type can be accessed via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"130\">ezRTTI::GetProperties()</code>. There are different categories of properties, each deriving from <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"130\">ezAbstractProperty</code>. The type of property can be determined by calling <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"130\">ezAbstractProperty::GetCategory()</code>.\nProperties are added via the property macros inside the <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"131\">EZ_BEGIN_PROPERTIES()</code> / <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"131\">EZ_END_PROPERTIES()</code> block of the type declaration like this:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"133\">EZ_BEGIN_STATIC_REFLECTED_TYPE(ezStaticTestClass, ezNoBase, 1, ezRTTIDefaultAllocator&lt;ezStaticTestClass&gt;)\n{\n    EZ_BEGIN_PROPERTIES\n    {\n        EZ_CONSTANT_PROPERTY(&quot;Constant&quot;, 5),\n        EZ_MEMBER_PROPERTY(&quot;Member&quot;, m_fFloat),\n        EZ_ACCESSOR_PROPERTY(&quot;MemberAccessor&quot;, GetInt, SetInt),\n        EZ_ARRAY_MEMBER_PROPERTY(&quot;Array&quot;, m_Deque),\n        EZ_ARRAY_ACCESSOR_PROPERTY(&quot;ArrayAccessor&quot;, GetCount, GetValue, SetValue, Insert, Remove),\n        EZ_SET_MEMBER_PROPERTY(&quot;Set&quot;, m_SetMember),\n        EZ_SET_ACCESSOR_PROPERTY(&quot;SetAccessor&quot;, GetSet, SetInsert, SetRemove),\n    }\n    EZ_END_PROPERTIES\n}\nEZ_END_STATIC_REFLECTED_TYPE();\n</code></pre>\n<h3 id=\"constants\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"151\">Constants</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"153\">Constants are declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"153\">EZ_CONSTANT_PROPERTY(PropertyName, Value)</code>. The value is stored within the property so no instance of the class is necessary to access it. To access the constant, cast the property to <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"153\">ezAbstractConstantProperty</code> and call <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"153\">ezAbstractConstantProperty::GetPropertyType()</code> to determine the constant type. Then either cast to <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"153\">ezTypedConstantProperty</code> of the matching type, or if the type is not known to you at compile time, use <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"153\">ezAbstractConstantProperty::GetPropertyPointer()</code> to access its data.</p>\n<h3 id=\"members\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"155\">Members</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"157\">There are two types of member properties, direct member properties and accessor properties. The first has direct access to the memory location of the property in the class while the later uses functions to get and set the property's value.\nDirect member properties are declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"158\">EZ_MEMBER_PROPERTY(PropertyName, MemberName)</code> while accessor properties are declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"158\">EZ_ACCESSOR_PROPERTY(PropertyName, Getter, Setter)</code>. The getter and setter functions must have the following signature:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"160\">Type GetterFunc() const;\nvoid SetterFunc(Type value);\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"165\">Type can be decorated with const and reference but must be consistent between get and set function. The available macros are the following:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"167\">EZ_MEMBER_PROPERTY(&quot;Member&quot;, m_fFloat1),\nEZ_MEMBER_PROPERTY_READ_ONLY(&quot;MemberRO&quot;, m_vProperty3),\nEZ_ACCESSOR_PROPERTY(&quot;MemberAccessor&quot;, GetInt, SetInt),\nEZ_ACCESSOR_PROPERTY_READ_ONLY(&quot;MemberAccessorRO&quot;, GetInt),\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"174\">To access an instance's member variable value, cast the property to <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"174\">ezAbstractMemberProperty</code> and call <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"174\">ezAbstractMemberProperty::GetPropertyType()</code> to determine the member type. Then either cast to <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"174\">ezTypedMemberProperty</code> of the matching type, or if the type is not known to you at compile time, use <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"174\">ezAbstractMemberProperty::GetPropertyPointer()</code> or <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"174\">ezAbstractMemberProperty::GetValuePtr()</code> and <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"174\">ezAbstractMemberProperty::SetValuePtr()</code> to access its data. The first solution will only return a valid pointer if the property is a direct member property.</p>\n<h3 id=\"arrays\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"176\">Arrays</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"178\">Array properties are very similar to member properties, they just handle arrays instead of single values. Direct array properties are declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"178\">EZ_ARRAY_MEMBER_PROPERTY(PropertyName, MemberName)</code> while accessor array properties are declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"178\">EZ_ARRAY_ACCESSOR_PROPERTY(PropertyName, GetCount, Getter, Setter, Insert, Remove)</code>. The accessor interface functions must have the following signature:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"180\">ezUInt32 GetCount() const;\nType GetValue(ezUInt32 uiIndex) const;\nvoid SetValue(ezUInt32 uiIndex, Type value);\nvoid Insert(ezUInt32 uiIndex, Type value);\nvoid Remove(ezUInt32 uiIndex);\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"188\">The available macros are the following:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"190\">EZ_ARRAY_ACCESSOR_PROPERTY(&quot;ArrayAccessor&quot;, GetCount, GetValue, SetValue, Insert, Remove),\nEZ_ARRAY_ACCESSOR_PROPERTY_READ_ONLY(&quot;ArrayAccessorRO&quot;, GetCount, GetValue),\nEZ_ARRAY_MEMBER_PROPERTY(&quot;Hybrid&quot;, m_Hybrid),\nEZ_ARRAY_MEMBER_PROPERTY(&quot;Dynamic&quot;, m_Dynamic),\nEZ_ARRAY_MEMBER_PROPERTY_READ_ONLY(&quot;Deque&quot;, m_Deque),\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"198\">To access an instance's array, cast the property to <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"198\">ezAbstractArrayProperty</code> and call <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"198\">ezAbstractArrayProperty::GetElementType()</code> to determine the element type. From here you can use the various functions inside <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"198\">ezAbstractArrayProperty</code> to manipulate an instance's array.</p>\n<h3 id=\"sets\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"200\">Sets</h3>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"202\">Set properties are very similar to member properties, they just handle sets instead of single values. Direct set properties are declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"202\">EZ_SET_MEMBER_PROPERTY(PropertyName, MemberName)</code> while accessor set properties are declared via <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"202\">EZ_SET_ACCESSOR_PROPERTY(PropertyName, GetValues, Insert, Remove)</code>. The accessor interface functions must have the following signature:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"204\">void Insert(Type value);\nvoid Remove(Type value);\nContainer&lt;Type&gt; GetValues() const;\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"210\">The available macros are the following:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"212\">EZ_SET_ACCESSOR_PROPERTY(&quot;SetAccessor&quot;, GetValues, Insert, Remove),\nEZ_SET_ACCESSOR_PROPERTY_READ_ONLY(&quot;SetAccessorRO&quot;, GetValues),\nEZ_SET_MEMBER_PROPERTY(&quot;Set&quot;, m_SetMember),\nEZ_SET_MEMBER_PROPERTY_READ_ONLY(&quot;SetRO&quot;, m_SetMember),\n</code></pre>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"219\">To access an instance's set, cast the property to <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"219\">ezAbstractSetProperty</code> and call <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"219\">ezAbstractSetProperty::GetElementType()</code> to determine the element type. From here you can use the various functions inside <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"219\">ezAbstractSetProperty</code> to manipulate an instance's set.</p>\n<h2 id=\"flags\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"221\">Flags</h2>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"223\">Types as well as properties have flags that quickly let you determine the kind of type / property you are dealing with.\nFor types, <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"224\">ezRTTI::GetTypeFlags()</code> lets you access its <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"224\">ezTypeFlags::Enum</code> flags which are automatically deduced from the type at compile time.</p>\n<p sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"226\">Properties can have flags as well, <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"226\">ezAbstractMemberProperty::GetFlags()</code>, <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"226\">ezAbstractArrayProperty::GetFlags()</code> and <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"226\">ezAbstractSetProperty::GetFlags()</code> let you access the <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"226\">ezPropertyFlags::Enum</code> flags of the handled property type. The only difference here is that besides automatically deduced flags there are also user-defined flags that can be added during declaration of the property by using <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"226\">ezAbstractMemberProperty::AddFlags</code> and the variants on the other property categories:</p>\n<pre><code class=\"lang-cpp\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"228\">EZ_ACCESSOR_PROPERTY(&quot;ArraysPtr&quot;, GetArrays, SetArrays)-&gt;AddFlags(ezPropertyFlags::PointerOwner),\n</code></pre>\n<h2 id=\"limitations\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"232\">Limitations</h2>\n<ul sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"234\">\n<li sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"234\">No two types can share the same name.</li>\n<li sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"235\">Each property name must be unique within its type.</li>\n<li sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"236\">Only constants that are a basic type (i.e. can be stored inside an <code sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"236\">ezVariant</code>) will be available to tools.</li>\n<li sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"237\">A pointer to a type cannot be its own type, the only exception to this is const char*.</li>\n</ul>\n<h2 id=\"see-also\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"239\">See Also</h2>\n",
  "type": "Conceptual",
  "source": {
    "remote": {
      "path": "pages/docs/runtime/reflection-system.md",
      "branch": "main",
      "repo": "https://github.com/ezEngine/docs-src"
    },
    "startLine": 0.0,
    "endLine": 0.0
  },
  "path": "pages/docs/runtime/reflection-system.md",
  "documentation": {
    "remote": {
      "path": "pages/docs/runtime/reflection-system.md",
      "branch": "main",
      "repo": "https://github.com/ezEngine/docs-src"
    },
    "startLine": 0.0,
    "endLine": 0.0
  },
  "_appFaviconPath": "assets/images/favicon.svg",
  "_appFooter": "Hello",
  "_appLogoPath": "assets/images/EZ-text.svg",
  "_appName": "ezEngine",
  "_appTitle": "ezEngine",
  "_enableGoogleAnalytics": true,
  "_enableNewTab": true,
  "_enableSearch": true,
  "_gitContribute": {
    "repo": "https://github.com/ezEngine/docs-src",
    "branch": "main"
  },
  "_systemKeys": [
    "conceptual",
    "type",
    "source",
    "path",
    "documentation",
    "title",
    "rawTitle",
    "wordCount"
  ],
  "rawTitle": "<h1 id=\"reflection-system\" sourcefile=\"pages/docs/runtime/reflection-system.md\" sourcestartlinenumber=\"1\">Reflection System</h1>",
  "title": "Reflection System",
  "wordCount": 1297.0,
  "_key": "pages/docs/runtime/reflection-system.md",
  "_navKey": "~/toc.yml",
  "_navPath": "toc.html",
  "_navRel": "../../../toc.html",
  "_path": "pages/docs/runtime/reflection-system.html",
  "_rel": "../../../",
  "_tocKey": "~/pages/docs/toc.md",
  "_tocPath": "pages/docs/toc.html",
  "_tocRel": "../toc.html",
  "__global": {
    "namespacesInSubtitle": "Namespaces",
    "classesInSubtitle": "Classes",
    "structsInSubtitle": "Structs",
    "interfacesInSubtitle": "Interfaces",
    "enumsInSubtitle": "Enums",
    "delegatesInSubtitle": "Delegates",
    "constructorsInSubtitle": "Constructors",
    "fieldsInSubtitle": "Fields",
    "propertiesInSubtitle": "Properties",
    "methodsInSubtitle": "Methods",
    "eventsInSubtitle": "Events",
    "operatorsInSubtitle": "Operators",
    "eiisInSubtitle": "Explicit Interface Implementations",
    "functionsInSubtitle": "Functions",
    "variablesInSubtitle": "Variables",
    "typeAliasesInSubtitle": "Type Aliases",
    "membersInSubtitle": "Members",
    "improveThisDoc": "Edit this page",
    "viewSource": "View Source",
    "inheritance": "Inheritance",
    "derived": "Derived",
    "inheritedMembers": "Inherited Members",
    "package": "Package",
    "namespace": "Namespace",
    "assembly": "Assembly",
    "syntax": "Syntax",
    "overrides": "Overrides",
    "implements": "Implements",
    "remarks": "Remarks",
    "examples": "Examples",
    "seealso": "See Also",
    "declaration": "Declaration",
    "parameters": "Parameters",
    "typeParameters": "Type Parameters",
    "type": "Type",
    "name": "Name",
    "description": "Description",
    "returns": "Returns",
    "fieldValue": "Field Value",
    "propertyValue": "Property Value",
    "eventType": "Event Type",
    "variableValue": "Variable Value",
    "typeAliasType": "Type Alias Type",
    "exceptions": "Exceptions",
    "condition": "Condition",
    "extensionMethods": "Extension Methods",
    "note": "Note",
    "warning": "Warning",
    "tip": "Tip",
    "important": "Important",
    "caution": "Caution",
    "tocToggleButton": "Show / Hide Table of Contents",
    "tocFilter": "Filter by title",
    "search": "Search",
    "searchResults": "Search Results for",
    "searchResultsCount": "{count} results for \"{query}\"",
    "searchNoResults": "No results for \"{query}\"",
    "pageFirst": "First",
    "pagePrev": "Previous",
    "pageNext": "Next",
    "pageLast": "Last",
    "inThisArticle": "In this article",
    "nextArticle": "Next",
    "prevArticle": "Previous",
    "backToTop": "Back to top",
    "themeLight": "Light",
    "themeDark": "Dark",
    "themeAuto": "Auto",
    "changeTheme": "Change theme",
    "copy": "Copy",
    "downloadPdf": "Download PDF",
    "_shared": {}
  },
  "_disableToc": false,
  "docurl": "https://github.com/ezEngine/docs-src/blob/main/pages/docs/runtime/reflection-system.md/#L1"
}